-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.3).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Haskcalc.Expr.Par
  ( happyError
  , myLexer
  , pDecl
  , pListIdent
  , pListDecl
  , pExpr
  , pExpr1
  , pExpr2
  , pExpr3
  , pListExpr
  ) where

import Prelude

import qualified Haskcalc.Expr.Abs
import Haskcalc.Expr.Lex

}

%name pDecl Decl
%name pListIdent ListIdent
%name pListDecl ListDecl
%name pExpr Expr
%name pExpr1 Expr1
%name pExpr2 Expr2
%name pExpr3 Expr3
%name pListExpr ListExpr
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('      { PT _ (TS _ 1) }
  ')'      { PT _ (TS _ 2) }
  '*'      { PT _ (TS _ 3) }
  '+'      { PT _ (TS _ 4) }
  ';'      { PT _ (TS _ 5) }
  '='      { PT _ (TS _ 6) }
  'let'    { PT _ (TS _ 7) }
  '{'      { PT _ (TS _ 8) }
  '}'      { PT _ (TS _ 9) }
  L_Ident  { PT _ (TV $$)  }
  L_integ  { PT _ (TI $$)  }

%%

Ident :: { Haskcalc.Expr.Abs.Ident }
Ident  : L_Ident { Haskcalc.Expr.Abs.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Decl :: { Haskcalc.Expr.Abs.Decl }
Decl
  : Ident ListIdent '=' '{' ListDecl '}' { Haskcalc.Expr.Abs.FunDecl $1 $2 $5 }
  | 'let' Ident '=' Expr { Haskcalc.Expr.Abs.LetDecl $2 $4 }
  | Expr { Haskcalc.Expr.Abs.ExprDecl $1 }

ListIdent :: { [Haskcalc.Expr.Abs.Ident] }
ListIdent : {- empty -} { [] } | Ident ListIdent { (:) $1 $2 }

ListDecl :: { [Haskcalc.Expr.Abs.Decl] }
ListDecl
  : {- empty -} { [] }
  | Decl { (:[]) $1 }
  | Decl ';' ListDecl { (:) $1 $3 }

Expr :: { Haskcalc.Expr.Abs.Expr }
Expr
  : Expr1 '+' Expr { Haskcalc.Expr.Abs.Add $1 $3 } | Expr1 { $1 }

Expr1 :: { Haskcalc.Expr.Abs.Expr }
Expr1
  : Expr2 '*' Expr1 { Haskcalc.Expr.Abs.Mult $1 $3 } | Expr2 { $1 }

Expr2 :: { Haskcalc.Expr.Abs.Expr }
Expr2
  : Ident ListExpr { Haskcalc.Expr.Abs.App $1 $2 } | Expr3 { $1 }

Expr3 :: { Haskcalc.Expr.Abs.Expr }
Expr3
  : Ident { Haskcalc.Expr.Abs.Val $1 }
  | Integer { Haskcalc.Expr.Abs.Lit $1 }
  | '(' Expr ')' { $2 }

ListExpr :: { [Haskcalc.Expr.Abs.Expr] }
ListExpr : {- empty -} { [] } | Expr ListExpr { (:) $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

